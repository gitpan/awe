<?xml version="1.0" encoding="koi8-r"  standalone='yes'?>
<article title="Принципы и методики разботки веб-приложений">
<p>И так, существует два противоположных принципа (методики, если хотите)
разработки веб-приложений, я бы их назвал

<term>странично-ориентированный (СО)</term> и
<term>действие-ориентированный (ДО)</term> на одном сайте могут
находиться примеры и одного и другого подхода, более того вывод одной
html-страницы может быть реалищован срадствами, использующими сложно
сему из переплетений этих двух методик, но чаще всего это не
так. Первый метод, в настоящее время чаще всего используемый,
самособой навязывается всевозможными встраиваемыми в код html языками
и решениями типа <tech>PHP/ASP/JSP</tech> и <tech>HTML::Embperl</tech>
(если он вызывается не из скриптов), хотя они вовсе и не обязывают
именно такой стиль девеломпента, но зачастую разработчик столь увлечен
ими, что даже не задумыается о том, что может существовать другой путь
или приходит к этой мысле, когда уже слишком поздно и сайт разросся до
таких размеров, что проще его написать с нуля, чем переделывать.
Вторая методика используется по умолчанию, если вы пишете классические
CGI скрипты, чаще всего это делается на <tech>perl</tech>-е. Приверженцев этого
способа становится все меньше, тут сказывается и то, что зачастую те
кто пишет CGI скрипты на <tech>perl</tech>-е и не догадываются о существовании или
покрайней мере необходимости создания своей, технологии шаблонов, из
которых будет генерироваться html код и поэтому встраивают его прямо в
скрипт, что снижает и без того не легкую читаемость <tech>perl</tech>-кода и то,
что чаще всего всего этим занимается вебмастер, которому скорее всего
необходимо в кратчайщий срок создать на своем сайте небольшой форум
или систему голосования, <tech>PHP</tech> сюда подходит как нельзя лучше, ведь этот
вебмастер совмещает в себе роли и программиста и веб-дизайнера поэтому
у него пракатически не возникает сложностей в создании такого гибрида
программы и дизайна "в одном флаконе".
</p>
<p>
Но в крупных и сложных проектах странично-ориентированная методика
оказывается чаще всего неудачной и тут начинается поиск новых решений,
те кто использовал <tech>PHP</tech> чаще всего, наверное, находят <tech>Zope</tech>, новый
хороший объектно-ориентированный язык (<tech>Python</tech>) и оригинальная
технология прильщают. Если же человек или группа использовали
действие-ориентированную методику и писали на perl-е, то они наверное
будут смотреть в сторону <tech>HTML::Mason</tech>, <tech>BingoX</tech>, <tech>PAS</tech>, а скорее всего и
вовсе изобретут свою технологию, сначала, наверное, это будет
библиотека часто используемых функций, а потом и настоящий environment
для разработки web приложений и все это только для одного, но конечно
крупного, или нескольких проектов ведомых этой группой
программистов. Методика создания веб-приложений в этом случае останется
действие-ориентированной. Причина следующая.
</p>
<p>
В случае с <term>СО</term> пользователь вызывает конкректную страницу, в которой от
входных параметров зависит ее содержание, но только не шаблон. К
примеру: <link>http://localhost/userview.php?id=12</link> -  надо посмотреть запись
номер 12. Идеология шаблона <term>recordview.phtml</term> выглядела-бы примерно так:
</p>

<code name="record_view.phtml">
показать html header
вывести загланое меню сайта
показать запись номер id
показать html footer
</code>

<p>Бывают конечно и более сложные <term>СО</term>-шаблоны, в которых даже наблюдается
убогая подвижка в сторону от <term>СО</term>благодаря самогенерации некоторых
внутренних частей темплейта. К примеру, часто необходимо иметь на
экране список каких либо элементов, с возможность их единичного
удаления, в результате удачного завершений которого изображался бы
снова тот-же список, но уже без удаленного элемента, а в результате
неудачи выводилось бы сообщение информирующее об этом. Такой шаблон
мог-бы выглядеть следующим образом:
</p>

<code name="record_del.phtml">
показать html header
вывести загланое меню
сайта удалить запись номер id
если удалось, то
   вывести список записей
1
если нет, то
   вывести сообщение об ошибке удаления записи номер id

показать html footer
</code>

<p>Причем и в первом и во втором случае команда 'вывести' означает ни что
иное, как включение другого, более узкоспециализированного шаблона
нежнего уровня. Таким образом образуется дерево используемых шаблонов,
это нормально. Но представьте себе, что в этом 'более
узкоспецилизированном' шаблоне вывода 'списка записей' происходит
ошибка. Уловить-то мы ее наверняка сможем, а вот вывести сообщение о
ней? Кажется это должен делать тот же 'более узкоспециализированный'
шаблон что выводил сообщение об ошибке удаления записи? Хорошо, нам
прийдется сделать его вывод в шаблоне 'выпода списка записей', а если
мы уже начали вывод этого списка записей? На экране будет каша из
записей и сообщений. Значит необходимо сначала выполнить необходимое
действие, то для которого вызвали данный скрипт (собрать список
записей в нашем случае), скешировать его и в зависимости от результата
действия (в упрощенном варианте: удачно оно было завершено или нет)
предоставлять не только различную информацию (список или сообщение об
ошибке), но и делать это различным способом (шаблон выводи списка или
ошибки). А в нашем случае было-бы проще всего в результате удачного
завершения акции 'уделения записи' сделать redirect на URL выводящий
список записей... Но чаще всего ошибки в шаблонах вообще не ловят
(отчасти это правильно, шаблон не должен генерировать ошибки вообще,
но в случае с <term>СО</term>это невозможно принципиально) и поэтому на сайтах,
созданных на <tech>PHP</tech> нередко можно где-нибудь в середине или даже начале
страницы видеть системное сообщение о произошедшей при доступе к SQL
ошибке, причем глядя на само содержание странице видно, что эта ошибка
никак не сказалась на нет не отразилась - страница попрежнему гласит,
что "все нормально" и "мы с вами".</p>
<p>Действия в веб приложении похожи на запросы к базе, они являются
именно "действиями", командой на выполнение, а не динамическими
страницами, хотя в браузере кажется как-раз необорот. Поэтому
идеологически не верно строить эти приложения по
странично-ориентированному принципу.</p>

<p>Когда пользователь вызывает <link>http://localhost/record_del.phtml?id=12</link> он
просит не вывести ему 'страницу с информацией об удалении записи', а
совершить определенное действие. Значит необходимо сначала совершить
определенное действие, а уже затем, судя по его результатам выводит
необходимую страницу (запускать шаблон). Ведь это в нашем примере
<term>record_del.phtml</term> существует всего два варианта завершения действия -
удалось и не удалось, а в реальной жизна даже в случае с
<term>record_view.phtml</term> этих вариантов может быть много, как то:</p>

<list>
<l/>такой записи не найдено;
<l/>ошибка подсоединения к базе;
<l/>запись найдена и необходимо ее вывести;
<l/>запись найдена, но она слишком сложна и для ее вывода требуется специальный шаблон;
<l/>у вас нет доступа для просмотра этой записи;
<l/>и тд и тп
</list>

<p>И если пукты 1-2 можно, правильно и нужно объеденить в один шаблон -
шаблон вывода информации об ошибке, то для всех осталных наверное
прийдется делать отдельные темплейты.</p>
<p>Справедливости ради стоит заметить, что программисты пишущие
веб-приложения на perl-е, особенно начинающие, все равно умудряются
использовать <term>СО</term>метод, когда шаблон используемый для вывода
результатов операции (действия) не зависит от этих самых
результатов. И, к примеру, в шаблоне на Embperl вызываемом из скрипта
<term>record_del.pl</term> будет таже логическая схема:</p>
<code>
показать html header
вывести загланое меню сайта
удалить запись номер id
если удалось, то
    вывести сообщение о том, что зпись удалены

если нет, то
    вывести сообщение об ошибке удаления записи номер id

показать html footer
</code>

<p>Но в отличие от <tech>PHP</tech>, если основной процесс подготовки данных
происходит скрипте, в шаблоне в случае удачи вывести список записей
невозможно таких данных попросту нет или прийдется его подготавливать
заранее, по все тойже логической схеме: есле запись успешно удалена -
подготовить список записей. Именно поэтому многие бросают тщетные
попытки строить веб приложения на перле по принципу perl
script->template и переходят на <tech>PHP</tech>, где позже натыкаются на еще выше
описанные проблемы. Хотя, кажется, большинство <tech>PHP</tech> программистов эти
проблемы попросту не волнуют, они о них или не задумываются или
банально игнорируют, потому-что если этого не делать, то оказывается,
что самого, столько разрекламированного и любимого, <tech>PHP</tech> для создания
качественного web-сайта оказывается мало, необходима еще методика,
технология, а это не просто набор процедур для веб-девелопмента.</p>


<p>Но не будем о грустном. Как вы уже догодались, я хочу сказать, что <term>ДО</term>
метод является панацеей и веб приложения должны строиться по его
принципу. Конечо не обязательно все и даже не обязательно весь сайт
целиком, можно легко придумать множество случаев, когда достаточно
<term>СО</term>, но всеже на <term>ДО</term> стоит покрайней мере обратить внимание.</p>



<p>Это можно увидить на
примере часто встречающегося в сети простенького форума, который уммет
совершать следующие действия (заметьте - совершать действия, я на
показывать страницы, и тем неменее):</p>

<list>
<l/>	добавить пользователя (само регистрация),
<l/>	изменить имя пользователя,
<l/>	удалить пользователя,
<l/>	посмотреть список пользователей,
<l/>	посмотреть список писем по темам,
<l/>	посмотреть письмо,
<l/>	написать письмо,
<l/>	написать ответ,
<l/>	удалить письмо.
</list>
<p>
Список действий может быть и гораздо шире, но это не столь важно.  Уже
сейчас мы видим, что каждое действие совершается над определенным
объектом и даже в описании этих действий так и хочется их
классифицировать по этим объектам, но не будем забегать вперед. Никто
не удивится, если набор скриптов реализующих этот форум будут иметь
невнятные названия типа:</p>
<code>
 useradd.pl, changename.pl, userdel.pl, userlist.pl, message.pl,

 message.pl, newmessage.pl, replay.pl, messagedel.pl
</code>

<p>
В  свою очередь каждый  скрипт  принимает только ему  требуемый список
параметров, каждый  по  своему  их  обрабатывает  и  тем более  выдает
информацию   в различном  виде   и  зачастую выводом этой   информации
занимается тот же скрипт  (об альтернативном способе вывода информации
- темплейтах (шаблонах) поговорим ниже). А вот как в этом случае можно
и нужно  применить современные  (если   уже не классические)   методики
программирования я сейчас и расскажу.</p>


<table name="Таблица пользователей (users)">
<tr><td>login</td><td>логин (псевдоним) пользователя</td></tr>
<tr><td>name</td><td>имя</td></tr></table>


<table name="Таблица сообщений (messages)">
<tr><td>message_id</td><td>унакальный идентицикационный номер (ID) письма</td></tr>
<tr><td>subject</td><td>тема письма</td></tr>
<tr><td>text</td><td>текст письма</td></tr>
<tr><td>parent_id</td><td>ID оригинального письма, на которое это является ответом</td></tr>
<tr><td>login</td><td>логин (псевдоним) пользователя, который является автором письма</td></tr>
</table>

<p>Как  упоминалось   ранее,  даже  в   списке  действий  уже угадывается
возможность их  классификации и типизации.   Зачем же ее  упускать?  А
слова   "классификация"  и "типизация"  уже    на  водят  на  мысли об
объектной-ориентированности.  Именно!  Каждое действие из этого списка
совершается над определенным объектом  (в нашем случае это таблицы из
RDBMS), более того, действия все одинаковые, не заметили? Вот они:</p>

<list>
<l/>	получить список (message.pl, userlist.pl),
<l/>	удалить (userdel.pl,messagedel.pl),
<l/>	изменить (changename.pl),
<l/>	создать (newmessage.pl,replay.pl, useradd.pl),
<l/>	посмотреть одну запись (message.pl).
</list>
<p>
Значит мы уже  имеем объекты и действия  производимые над ними (в ООП -
методы).   Напоминаю, что в нашем примере  все действия происходят над
таблицами и единственное  чем отличается объект 'пользователи'  (users)
от   'письма' (messages)    это   названем самой  таблицы   и  списком
используемых  в   ней полей.  Если  в   случае создания пользователя в
таблице users создается новая запись которой с полем NAME, то в случае
с письмом поля будут TEXT, SUBJECT и  LOGIN.  Так это же классической
ООП: есть  объекты, у   них  есть  совершено идентичные   методы, сами
объекты  отличаются только  своствами, значит можно  и резонно создать
класс, экземпляром которого и будут являться наши объекта. Назавем его
к  примеру WebTable.  То  есть    методы у наших объектов   настолько
идентичные, что (пока) нет даже    необходимости использовать одну   и
лучших возможностей ООП   -   иерархию наследования или   если  хотите
расширения. </p>

<p>
Несмотря на то, что код самих программ я буду приводить на языке Perl,
описание класса, на мой взгляд, нагляднее делать на неком абстрактном
C++/Java языке:</p>

<code>
class WebTable {
	public:
	WebTable(tableName,attrs);
	~WebTable();

	result create(fields);
    // Создание новой записи с полями fields
 	result delete(id);
    // Удаление записи с конкретным ID
 	result change(id,fields); 
    // Изменение полей fields записи с указанным id
 	fields load(id);          
    // Получить значение полей fields записи id
 	fieldsList list();            
    // Получить список всех записей

	private:

  string tableName;         
    // Имя таблицы
	string idName;            
    // Название ID таблицы
	string attr[MAX];         
    // Список используемых в таблице полей
};
</code>

<p>в таком случае объекты из нашего примера будут инициализироваться
следующим образом:</p>

<code>
 WebTable users('users','LOGIN',['name']);

 WebTable messages('messages','MESSAGE_ID',['subject','text','LOGIN']);
</code>

<p>А теперь настоящий класс WebTable на Perl-е.</p>


<code>### WebTable.pm</code>


<p>Естественно этот модуль является примером, хотя и рабочим, в реальной
жизни он будет больше и сложнее, так как должен содержать код
обработки ошибок и некоторых не стандартны ситуаций, как например
передача неверных параметров методам.  Но уже даже в таком виде он
может использоваться в разработках. Для того, что бы пример был полным
и исчерпывающим приведу основной код нашего форума, который в свою
очередь и будет использовать класс WebTable. </p>

<code>###engine.pl</code>

<p>
Скрипту передаются имя объекта и название необходимого действия в
параметрах object и action соотвественно. Кроме этого при необходимости
срипту передаются параметры в осответсвии с действием и объектом. Сам
скрипт работает в трех режимах:</p>

<list>
<l/> (по умолчанию) Если скрипт запущен без указания объекта, он выводит

форму <TERM>со</TERM>списком возможных объектов в процедуре showObjectsList;

<l/> Если указано верное имя объекта (следующий шаг, после 1-й формы),

то при помощи процедуры shotActionsList выдается несколько форм, с
необходимыми полями для всех воможных действий над объектом. 
<l/> Если и объект и действия указанные, то совершается соответствующее

действие и запускается процедура вывода информации output.
</list>

<p>!!! Обратить внимание, что появились новые методы для объектов</p>

<p>К сожалению Perl не смотря на всю свою мощь (а скорее всего и
благодаря) не является разборчивым и понятным для изучения алгоритмов
языком, но вы наверняка обратили внимание на то, что большую часть
скрипта занимают процедуры вывода информации, а не их обработки. 
Во-первых это действительно так, практически в любой программе,
большую часть всего кода, зачастую доходящую до 90-95% отобщего числа
строк в коде.  Веб-приложения не исключения.  Важно и необходимо
отметить, что даже в нашем маленьком примере существует четкая грань
между операцией обработки и подготовки данных (по сути это пара строк
запроса к базе в модуле WebTable) и процедурой вывода. Это правильное
решение, к которому пришли наверное уже все проектировщики и дизайнеры
ПО.  Если при переходе от процедурно-ориентированного метода
програмирования к объектно-оприентированному был девиз - данные и код
отдельно, то теперь, особенно в миру веб-девелопмента (а на мой взгляд
эту же схему абсолютно необходимо применять и создании обычных офисных
приложений) есть смысл использовать отделение кода обработки,
подготовки и собственно вывода данных (который, я повторюсь, занимает
большую и самую неинтересную, на мой взгляд, часть времени создании
веб-приложений большую часть времени и кода). Кроме того, блок вывода
информации почти всегда совпадает с интерфейсной частью приложения, а
в вебе интерфейсной частью занимается веб-дизайнер и тут возникает
прямая ниобходимость разделения кода на програмерский и дизайнерский. 
Естественно веб-дизайнер скорее всего не знает (да и не должен) не то
что бы язык Perl (на помню еще раз про его непонятность, даже человеку
имеющему большой опыт кодирования скриптов на perl-е стоит больших
трудов разбираться в коде, автором которого он не является или являлся
очень давно. В таком случае мало помогают даже комментарии, о большой
роли которых всеже не стоит забывать), а даже более изящный и
направленный на встраивание прямо в html код <tech>PHP</tech>. Конечно в небольших
приложениях, как этот пример использования форум-движка.  Но если мы
захотим пойти дальше и сделать на этом движке настоящий форум, даже с
такой небольшой функциональностью, код html может возрасти в десятки
раз и тут уже не обойтись без использования темплейтов (шаблонов) лучше
всего на эту роль подходит <tech>PHP</tech>, но к сожалению удачных методов
perl-php содружества не существует (причины создания ядра приложения
не perl-е, а не сразу на php выходят за рамки этой статьи), поэтому
для таких целей используются различные решения, как-то простой и
быстрый модуль HTML::Template, мощнная среда разработки HTML::Masson
или часто используемый и гибкий HTML::Embperl, являющий по сути
perl-ом пошедшем по стопам <tech>PHP</tech>.  <tech>HTML::Embperl</tech> дает банальную
возможность встраивать любые конструкции языка perl в html код, а дабы
пожалеть дизайнера и не отвлекать его от основного занятия эти
консртукций должно быть как можно меньше, реально можно обойтись
тремя: командами условного перехода <code>if/else/endif</code>,
циклами <code>foreach/endforeach</code>, и вложениями <code>Execute</code>
,фактически являющимися запуском внешних темплейтов.  В зависимости
от действия и объекта необходимо запускать различные темплейты.  Это
решается достаточно просто, имя темплейта можно указать напрямую в
процедуре обработки указаного действия или вычислять имя темплейта в
зависимости от вызванного объекта и действия, например как
<file>object_action.html</file>, то есть в случае вызова

<url>forum.pl?object=messages&amp;action=list</url>

будет выводиться темплейт
<file>messages_list.html</file>. Лично я предпочитаю оба метода, в таком варианте,
в том случае если действием напрямую название темплейта не
установленно - вычислять его по указанному выше методу. </p>

<p>
Для безопасности необходимо также ограничить возможность запуска любых
методов указанных объектов, если к примеру вы опишите в своем объекте
некоторые внутренние методы, которые во собирались запускать только по
внутренним нуждам и которые по сути не являются ожидаемыми действиями
на объектом выполняемыми по запросу пользователя, то тем менее
существует возможность их запуска, если пользователь знает их имя, а
это потенциальная дыра в безопасности.  Эту проблему предлагается
решить просто - все внешние действия (акции) должны называться как
ACTION_действие, а само название действие не должно содержать символом
кроме букв, цифр и знака подчеркивания. Кроме этого я предпочитаю
указывать темплейт по его названию, а не по имени файла и тем более
абсолютному его пути. Для этого должен существовать конфиг-хеш всех
возможных темплейтов, а это помогает еще в одном деле. <tech>HTML::Embperl</tech>
имеет возможность работать с темплейтами как с объектами, они
загружаются в память, компилируются и уже затем вызываются по мере
надобности, это полезно в том случае, если вы используете mod_perl,
который компилирует и загружает скрипты в память при первом запуске
веб-сервера, а затем уже при каждом запросе выполняет их заново, что
позволяет не только сэкономить время, которое тратилось-бы на
загрузку, проверку и ситнекса скриптов при каждом запросе, но и
использовать кеш-память. Например при первом запуске скрипта считать
конфигурационный файл, я при последующих вызовах использовать данные
из памяти. Так-вот, благодаря тому, что у нас есть поименный список
всех используемых в нашей прогармме темплейтов, мы может при первом
запуске скрипта загрузить и откомпилировать их, а затем уже вызывать
указанный. </p>

<p>
Форум может помимо страниц генерируемых нашими messages и users
объектами иметь и другие? Например это может быть заглавная страница,
страница помощи или страница с кооринатами владельцев и
создателей.  Как быть с ними? По сути они являются статическими и их
можно создать настоящими html-файлами и вызвать на прямую (вполне
неплохой метод), а можно создать объект пустышку, содержащий ничего не
делающие действия типа sub <code>ACTION_index {1;}</code> и работать с ним.  Я
предпочитаю последнее, потому что зачастую абсолютно статические
страницы превращяются в динамические, на пример вдруг вы решили на
заглавной странице выводить имя зашедшего пользователя или новости
своего сайта?  В таком случае, конфигурационный хеш, в котором
указывалиь данные для инициализации веб-объекта должен содержать еще и
имя модуля-класса этого объекта</p>

<p>И вот, что у нас вышло:</p>

<code>### WebTable.pm</code>

<p>
!!! практика делать по одному скрипту на одной действие негативно сказывается на воможности расширения и поддержки все системы
!!! zope:content-management system with a simple Web interface
!!! Тупиковый пусть,если идти  не правильный путем, путем <term>СО</term>и всяких *SP
!!! Действие в веб приложения похожи на запросы, поэтому идеологически не верно строить эти приложения по странично-ориентированному принципу
</p>


</article>